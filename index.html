<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Unit Circle Snake Game</title>
  <!-- KaTeX CSS for math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
  <style>
    body { margin: 0; padding: 0; font-family: sans-serif; background: #f2f2f2; }
    /* Container for the game view */
    #game-container { position: relative; width: 640px; height: 480px; margin: 20px auto; background: #fff; border: 2px solid #333; }
    /* Canvas for drawing snake and grid */
    canvas { position: absolute; top: 80px; left: 0; }
    /* The question div at the top */
    #question { position: absolute; top: 0; left: 0; width: 100%; height: 80px; background: #eee; border-bottom: 2px solid #333; display: flex; align-items: center; justify-content: center; font-size: 24px; }
    /* Lives indicator (using hearts) */
    #lives { position: absolute; top: 10px; right: 10px; font-size: 24px; color: red; }
    /* Food elements are absolutely positioned divs */
    .food { position: absolute; width: 20px; height: 20px; pointer-events: none; }
    /* Simple menu and settings styles */
    #menu, #settings { width: 640px; height: 480px; margin: 20px auto; background: #f2f2f2; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    .button { margin: 10px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; }
    .checkbox { margin: 5px; }
  </style>
</head>
<body>
  <!-- Main Menu -->
  <div id="menu">
    <h1>Unit Circle Snake Game</h1>
    <button id="playButton" class="button">Play</button>
    <button id="settingsButton" class="button">Settings</button>
  </div>
  <!-- Settings Screen -->
  <div id="settings" style="display:none;">
    <h1>Settings</h1>
    <div>
      <label class="checkbox"><input type="checkbox" id="sinCheckbox" checked> sin</label>
      <label class="checkbox"><input type="checkbox" id="cosCheckbox" checked> cos</label>
      <label class="checkbox"><input type="checkbox" id="tanCheckbox" checked> tan</label>
    </div>
    <div>
      <label class="checkbox"><input type="checkbox" id="quad1" checked> Quadrant 1</label>
      <label class="checkbox"><input type="checkbox" id="quad2" checked> Quadrant 2</label>
      <label class="checkbox"><input type="checkbox" id="quad3" checked> Quadrant 3</label>
      <label class="checkbox"><input type="checkbox" id="quad4" checked> Quadrant 4</label>
    </div>
    <button id="backButton" class="button">Back</button>
  </div>
  <!-- Game View -->
  <div id="game-container" style="display:none;">
    <div id="question"></div>
    <div id="lives"></div>
    <canvas id="gameCanvas" width="640" height="400"></canvas>
  </div>

  <!-- Load KaTeX -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script>
  <script>
    // Global variables and constants
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const questionDiv = document.getElementById("question");
    const livesDiv = document.getElementById("lives");
    const gameContainer = document.getElementById("game-container");
    const menuDiv = document.getElementById("menu");
    const settingsDiv = document.getElementById("settings");

    const CELL_SIZE = 20;
    const GRID_WIDTH = 640 / CELL_SIZE;
    const GRID_HEIGHT = 400 / CELL_SIZE; // canvas height is 400 (game board area)

    let gameInterval;
    let gameState = "menu"; // "menu", "settings", "playing"

    // Settings for functions and quadrants
    let settings = {
      functions: { sin: true, cos: true, tan: true },
      quadrants: { 1: true, 2: true, 3: true, 4: true }
    };

    // Game state variables
    let snake;
    let direction;
    let foods;
    let currentQuestion;
    let correctAnswer;
    let lives;
    let score;
    let foodElements = [];  // HTML elements for foods

    // Base values for each function (LaTeX strings)
    const baseValues = {
      sin: {
        "pi/6": "\\frac{1}{2}",
        "pi/4": "\\frac{\\sqrt{2}}{2}",
        "pi/3": "\\frac{\\sqrt{3}}{2}",
        "pi/2": "1"
      },
      cos: {
        "pi/6": "\\frac{\\sqrt{3}}{2}",
        "pi/4": "\\frac{\\sqrt{2}}{2}",
        "pi/3": "\\frac{1}{2}",
        "pi/2": "0"
      },
      tan: {
        "pi/6": "\\frac{1}{\\sqrt{3}}",
        "pi/4": "1",
        "pi/3": "\\sqrt{3}"
      }
    };
    const baseAngles = {
      "pi/6": Math.PI / 6,
      "pi/4": Math.PI / 4,
      "pi/3": Math.PI / 3,
      "pi/2": Math.PI / 2
    };

    // Helper: Format the full angle (as LaTeX) based on a base and quadrant.
    function formatAngle(base, quadrant) {
      let angle = baseAngles[base];
      if (base === "pi/2") {
        return (quadrant <= 2) ? "\\frac{\\pi}{2}" : "\\frac{3\\pi}{2}";
      }
      let full;
      if (quadrant === 1) {
        full = angle;
      } else if (quadrant === 2) {
        full = Math.PI - angle;
      } else if (quadrant === 3) {
        full = Math.PI + angle;
      } else if (quadrant === 4) {
        full = 2 * Math.PI - angle;
      }
      // For our allowed angles, we know the fractional forms.
      let denom;
      if (base === "pi/6") denom = 6;
      else if (base === "pi/4") denom = 4;
      else if (base === "pi/3") denom = 3;
      let ratio = full / Math.PI;
      let numerator = Math.round(ratio * denom);
      return "\\frac{" + numerator + "\\pi}{" + denom + "}";
    }

    // Helper: Adjust the answer based on function and quadrant (adds minus sign as needed).
    function getAdjustedAnswer(func, base, quadrant) {
      let val = baseValues[func][base];
      if (func === "sin") {
        if (quadrant === 3 || quadrant === 4) return "-" + val;
      } else if (func === "cos") {
        if (quadrant === 2 || quadrant === 3) return "-" + val;
      } else if (func === "tan") {
        if (quadrant === 2 || quadrant === 4) return "-" + val;
      }
      return val;
    }

    // Generate a new question
    function generateQuestion() {
      let funcs = [];
      for (let f in settings.functions) {
        if (settings.functions[f]) funcs.push(f);
      }
      if (funcs.length === 0) funcs.push("sin");
      let func = funcs[Math.floor(Math.random() * funcs.length)];
      let bases = (func === "tan") ? ["pi/6", "pi/4", "pi/3"] : ["pi/6", "pi/4", "pi/3", "pi/2"];
      let base = bases[Math.floor(Math.random() * bases.length)];
      let quads = [];
      for (let q in settings.quadrants) {
        if (settings.quadrants[q]) quads.push(parseInt(q));
      }
      if (quads.length === 0) quads.push(1);
      let quadrant = quads[Math.floor(Math.random() * quads.length)];
      let angleStr = formatAngle(base, quadrant);
      let questionLatex = func + "(" + angleStr + ")";
      let answerLatex = getAdjustedAnswer(func, base, quadrant);
      return { func, questionLatex, answerLatex, base, quadrant };
    }

    // Initialize game state
    function initGame() {
      snake = [{ x: Math.floor(GRID_WIDTH/2), y: Math.floor(GRID_HEIGHT/2) }];
      direction = { x: 1, y: 0 };
      lives = 3;
      score = 0;
      currentQuestion = generateQuestion();
      correctAnswer = currentQuestion.answerLatex;
      foods = generateFoods(currentQuestion.func, correctAnswer, snake);
      updateFoodElements();
      updateQuestion();
      updateLives();
    }

    // Generate foods (one correct and three distractors)
    function generateFoods(func, correctAnswer, snakePositions) {
      let possible = new Set();
      let bases = (func === "tan") ? ["pi/6", "pi/4", "pi/3"] : ["pi/6", "pi/4", "pi/3", "pi/2"];
      for (let b of bases) {
        for (let q = 1; q <= 4; q++) {
          possible.add(getAdjustedAnswer(func, b, q));
        }
      }
      possible.delete(correctAnswer);
      let distractors = Array.from(possible);
      // Randomly pick up to 3 distractors
      distractors = distractors.sort(() => Math.random() - 0.5).slice(0, Math.min(3, distractors.length));
      let foodValues = distractors.concat([correctAnswer]);
      foodValues = foodValues.sort(() => Math.random() - 0.5);
      let generatedFoods = [];
      for (let value of foodValues) {
        let pos = getRandomFoodPosition(snakePositions, generatedFoods);
        generatedFoods.push({ pos, value });
      }
      return generatedFoods;
    }

    function getRandomFoodPosition(snakePositions, currentFoods) {
      let margin = 3;
      while (true) {
        let x = Math.floor(Math.random() * (GRID_WIDTH - 2 * margin)) + margin;
        let y = Math.floor(Math.random() * (GRID_HEIGHT - 2 * margin)) + margin;
        let conflict = snakePositions.some(s => s.x === x && s.y === y);
        if (conflict) continue;
        conflict = currentFoods.some(f => Math.abs(f.pos.x - x) < 3 && Math.abs(f.pos.y - y) < 3);
        if (conflict) continue;
        return { x, y };
      }
    }

    // Create or update food HTML elements (using KaTeX)
    function updateFoodElements() {
      // Remove old food elements
      foodElements.forEach(el => el.remove());
      foodElements = [];
      for (let food of foods) {
        let div = document.createElement("div");
        div.className = "food";
        div.style.left = (food.pos.x * CELL_SIZE) + "px";
        div.style.top = ((food.pos.y * CELL_SIZE) + 80) + "px"; // offset for question area
        katex.render(food.value, div, { throwOnError: false, displayMode: false });
        gameContainer.appendChild(div);
        foodElements.push(div);
      }
    }

    // Update question display using KaTeX
    function updateQuestion() {
      katex.render(currentQuestion.questionLatex, questionDiv, { throwOnError: false, displayMode: true });
    }

    // Update lives display (using hearts)
    function updateLives() {
      livesDiv.innerHTML = "â™¥".repeat(lives);
    }

    // Draw the game board and snake on the canvas
    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Optional grid lines
      ctx.strokeStyle = "#ddd";
      for (let i = 0; i <= GRID_WIDTH; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, canvas.height);
        ctx.stroke();
      }
      for (let j = 0; j <= GRID_HEIGHT; j++) {
        ctx.beginPath();
        ctx.moveTo(0, j * CELL_SIZE);
        ctx.lineTo(canvas.width, j * CELL_SIZE);
        ctx.stroke();
      }
      // Draw snake
      ctx.fillStyle = "green";
      for (let cell of snake) {
        ctx.fillRect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
      }
    }

    // Game update: move snake, check collisions, update state.
    function updateGame() {
      let newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
      // Check wall collisions
      if (newHead.x < 0 || newHead.x >= GRID_WIDTH || newHead.y < 0 || newHead.y >= GRID_HEIGHT) {
        endGame();
        return;
      }
      // Check self-collision
      if (snake.some(cell => cell.x === newHead.x && cell.y === newHead.y)) {
        endGame();
        return;
      }
      snake.unshift(newHead);
      // Check if snake head is on a food cell (if any part of snake's head cell touches the food cell)
      let hitFoodIndex = foods.findIndex(f => f.pos.x === newHead.x && f.pos.y === newHead.y);
      if (hitFoodIndex !== -1) {
        let food = foods[hitFoodIndex];
        if (food.value === correctAnswer) {
          score++;
          // Generate new question and foods
          currentQuestion = generateQuestion();
          correctAnswer = currentQuestion.answerLatex;
          foods = generateFoods(currentQuestion.func, correctAnswer, snake);
          updateFoodElements();
          updateQuestion();
        } else {
          lives--;
          updateLives();
          // Remove the wrong food
          foods.splice(hitFoodIndex, 1);
          let fe = foodElements.splice(hitFoodIndex, 1)[0];
          fe.remove();
          // Do not grow the snake
          snake.pop();
          if (lives <= 0) {
            endGame();
            return;
          }
        }
      } else {
        // Normal move: remove tail
        snake.pop();
      }
      drawGame();
    }

    function endGame() {
      clearInterval(gameInterval);
      alert("Game Over! Score: " + score);
      showMenu();
    }

    // Handle keyboard input for direction changes
    document.addEventListener("keydown", function(e) {
      if (gameState !== "playing") return;
      if (e.key === "ArrowUp" && direction.y !== 1) {
        direction = { x: 0, y: -1 };
      } else if (e.key === "ArrowDown" && direction.y !== -1) {
        direction = { x: 0, y: 1 };
      } else if (e.key === "ArrowLeft" && direction.x !== 1) {
        direction = { x: -1, y: 0 };
      } else if (e.key === "ArrowRight" && direction.x !== -1) {
        direction = { x: 1, y: 0 };
      }
    });

    // Menu and settings handling
    document.getElementById("playButton").addEventListener("click", function() {
      showGame();
    });
    document.getElementById("settingsButton").addEventListener("click", function() {
      showSettings();
    });
    document.getElementById("backButton").addEventListener("click", function() {
      // Update settings from checkboxes
      settings.functions.sin = document.getElementById("sinCheckbox").checked;
      settings.functions.cos = document.getElementById("cosCheckbox").checked;
      settings.functions.tan = document.getElementById("tanCheckbox").checked;
      settings.quadrants[1] = document.getElementById("quad1").checked;
      settings.quadrants[2] = document.getElementById("quad2").checked;
      settings.quadrants[3] = document.getElementById("quad3").checked;
      settings.quadrants[4] = document.getElementById("quad4").checked;
      showMenu();
    });

    function showMenu() {
      gameState = "menu";
      menuDiv.style.display = "flex";
      settingsDiv.style.display = "none";
      gameContainer.style.display = "none";
    }
    function showSettings() {
      gameState = "settings";
      menuDiv.style.display = "none";
      settingsDiv.style.display = "flex";
      gameContainer.style.display = "none";
    }
    function showGame() {
      gameState = "playing";
      menuDiv.style.display = "none";
      settingsDiv.style.display = "none";
      gameContainer.style.display = "block";
      initGame();
      gameInterval = setInterval(updateGame, 1000 / 10);
    }

    // Start at the main menu.
    showMenu();
  </script>
</body>
</html>
