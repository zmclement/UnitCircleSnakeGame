<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Unit Circle Snake Game</title>
  <!-- KaTeX CSS for math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
  <style>
    body { margin: 0; padding: 0; font-family: sans-serif; background: #f2f2f2; }
    /* Container for the game view */
    #game-container { position: relative; width: 640px; height: 480px; margin: 20px auto; background: #fff; border: 2px solid #333; }
    /* Canvas for drawing snake (no grid lines now) */
    canvas { position: absolute; top: 80px; left: 0; }
    /* The question div at the top */
    #question { position: absolute; top: 0; left: 0; width: 100%; height: 80px; background: #eee; border-bottom: 2px solid #333; display: flex; align-items: center; justify-content: center; font-size: 24px; }
    /* Lives indicator */
    #lives { position: absolute; top: 10px; right: 10px; font-size: 24px; color: red; }
    /* Food elements are absolutely positioned divs */
    .food { position: absolute; width: 20px; height: 20px; pointer-events: none; }
    /* Menu and settings styling */
    #menu, #settings { width: 640px; height: 480px; margin: 20px auto; background: #f2f2f2; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
    .button { margin: 10px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; }
    .checkbox { margin: 5px; }
    #welcome { margin: 20px; font-size: 16px; }
  </style>
</head>
<body>
  <!-- Main Menu -->
  <div id="menu">
    <h1>Unit Circle Snake Game</h1>
    <p id="welcome">
      Welcome to my Unit Circle Snake Game! It plays like a normal snake game, except you can only grow by eating the correct answer to the question at the top of the screen. You have three wrong mistakes before the game is over! Use the settings to control which functions and quadrants are included. I hope this is helpful!
    </p>
    <button id="playButton" class="button">Play</button>
    <button id="settingsButton" class="button">Settings</button>
  </div>
  <!-- Settings Screen -->
  <div id="settings" style="display:none;">
    <h1>Settings</h1>
    <div>
      <label class="checkbox"><input type="checkbox" id="sinCheckbox" checked> sin</label>
      <label class="checkbox"><input type="checkbox" id="cosCheckbox" checked> cos</label>
      <label class="checkbox"><input type="checkbox" id="tanCheckbox" checked> tan</label>
    </div>
    <div>
      <label class="checkbox"><input type="checkbox" id="quad1" checked> Quadrant 1</label>
      <label class="checkbox"><input type="checkbox" id="quad2" checked> Quadrant 2</label>
      <label class="checkbox"><input type="checkbox" id="quad3" checked> Quadrant 3</label>
      <label class="checkbox"><input type="checkbox" id="quad4" checked> Quadrant 4</label>
    </div>
    <button id="backButton" class="button">Back</button>
  </div>
  <!-- Game View -->
  <div id="game-container" style="display:none;">
    <div id="question"></div>
    <div id="lives"></div>
    <canvas id="gameCanvas" width="640" height="400"></canvas>
  </div>

  <!-- Load KaTeX -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script>
  <script>
    // Global variables and constants
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const questionDiv = document.getElementById("question");
    const livesDiv = document.getElementById("lives");
    const gameContainer = document.getElementById("game-container");
    const menuDiv = document.getElementById("menu");
    const settingsDiv = document.getElementById("settings");

    const CELL_SIZE = 20;
    const GRID_WIDTH = 640 / CELL_SIZE;
    const GRID_HEIGHT = 400 / CELL_SIZE; // canvas height is 400

    let gameInterval;
    let gameState = "menu"; // "menu", "settings", "playing"

    // Settings for functions and quadrants
    let settings = {
      functions: { sin: true, cos: true, tan: true },
      quadrants: { 1: true, 2: true, 3: true, 4: true }
    };

    // Game state variables
    let snake;
    let direction;
    let foods;
    let currentQuestion;
    let correctAnswer;
    let lives;
    let score;
    let foodElements = [];  // HTML elements for foods

    // Base values for each function (LaTeX strings)
    const baseValues = {
      sin: {
        "pi/6": "\\frac{1}{2}",
        "pi/4": "\\frac{\\sqrt{2}}{2}",
        "pi/3": "\\frac{\\sqrt{3}}{2}",
        "pi/2": "1"
      },
      cos: {
        "pi/6": "\\frac{\\sqrt{3}}{2}",
        "pi/4": "\\frac{\\sqrt{2}}{2}",
        "pi/3": "\\frac{1}{2}",
        "pi/2": "0"
      },
      tan: {
        "pi/6": "\\frac{1}{\\sqrt{3}}",
        "pi/4": "1",
        "pi/3": "\\sqrt{3}"
      }
    };
    const baseAngles = {
      "pi/6": Math.PI / 6,
      "pi/4": Math.PI / 4,
      "pi/3": Math.PI / 3,
      "pi/2": Math.PI / 2
    };

    // Helper: Format the full angle (as LaTeX) based on a base and quadrant.
    function formatAngle(base, quadrant) {
      let angle = baseAngles[base];
      if (base === "pi/2") {
        return (quadrant <= 2) ? "\\frac{\\pi}{2}" : "\\frac{3\\pi}{2}";
      }
      let full;
      if (quadrant === 1) {
        full = angle;
      } else if (quadrant === 2) {
        full = Math.PI - angle;
      } else if (quadrant === 3) {
        full = Math.PI + angle;
      } else if (quadrant === 4) {
        full = 2 * Math.PI - angle;
      }
      // Determine denominator based on base angle.
      let denom;
      if (base === "pi/6") denom = 6;
      else if (base === "pi/4") denom = 4;
      else if (base === "pi/3") denom = 3;
      let ratio = full / Math.PI;
      let numerator = Math.round(ratio * denom);
      // If numerator is 1, return without the 1.
      if (numerator === 1) {
        return "\\frac{\\pi}{" + denom + "}";
      } else {
        return "\\frac{" + numerator + "\\pi}{" + denom + "}";
      }
    }

    // Helper: Adjust the answer based on function and quadrant.
    function getAdjustedAnswer(func, base, quadrant) {
      let val = baseValues[func][base];
      if (val === "0") {
        return "0";
    }
      if (func === "sin") {
        if (quadrant === 3 || quadrant === 4) return "-" + val;
      } else if (func === "cos") {
        if (quadrant === 2 || quadrant === 3) return "-" + val;
      } else if (func === "tan") {
        if (quadrant === 2 || quadrant === 4) return "-" + val;
      }
      return val;
    }

    // Generate a new question
    function generateQuestion() {
      let funcs = [];
      for (let f in settings.functions) {
        if (settings.functions[f]) funcs.push(f);
      }
      if (funcs.length === 0) funcs.push("sin");
      let func = funcs[Math.floor(Math.random() * funcs.length)];
      let bases = (func === "tan") ? ["pi/6", "pi/4", "pi/3"] : ["pi/6", "pi/4", "pi/3", "pi/2"];
      let base = bases[Math.floor(Math.random() * bases.length)];
      let quads = [];
      for (let q in settings.quadrants) {
        if (settings.quadrants[q]) quads.push(parseInt(q));
      }
      if (quads.length === 0) quads.push(1);
      let quadrant = quads[Math.floor(Math.random() * quads.length)];
      let angleStr = formatAngle(base, quadrant);
      let questionLatex = func + "(" + angleStr + ")";
      let answerLatex = getAdjustedAnswer(func, base, quadrant);
      return { func, questionLatex, answerLatex, base, quadrant };
    }

    // Initialize game state
    function initGame() {
      snake = [{ x: Math.floor(GRID_WIDTH/2), y: Math.floor(GRID_HEIGHT/2) }];
      direction = { x: 1, y: 0 };
      lives = 3;
      score = 0;
      currentQuestion = generateQuestion();
      correctAnswer = currentQuestion.answerLatex;
      foods = generateFoods(currentQuestion.func, correctAnswer, snake);
      updateFoodElements();
      updateQuestion();
      updateLives();
    }

    // Generate foods (one correct answer and three distractors)
    function generateFoods(func, correctAnswer, snakePositions) {
      let possible = new Set();
      let bases = (func === "tan") ? ["pi/6", "pi/4", "pi/3"] : ["pi/6", "pi/4", "pi/3", "pi/2"];
      for (let b of bases) {
        for (let q = 1; q <= 4; q++) {
          possible.add(getAdjustedAnswer(func, b, q));
        }
      }
      possible.delete(correctAnswer);
      let distractors = Array.from(possible);
      distractors = distractors.sort(() => Math.random() - 0.5).slice(0, Math.min(3, distractors.length));
      let foodValues = distractors.concat([correctAnswer]);
      foodValues = foodValues.sort(() => Math.random() - 0.5);
      let generatedFoods = [];
      for (let value of foodValues) {
        let pos = getRandomFoodPosition(snakePositions, generatedFoods);
        generatedFoods.push({ pos, value });
      }
      return generatedFoods;
    }

    // Get a random food position with a margin of 4 cells and ensuring foods are at least 4 cells apart.
    function getRandomFoodPosition(snakePositions, currentFoods) {
      let margin = 4;
      while (true) {
        let x = Math.floor(Math.random() * (GRID_WIDTH - 2 * margin)) + margin;
        let y = Math.floor(Math.random() * (GRID_HEIGHT - 2 * margin)) + margin;
        let conflict = snakePositions.some(s => s.x === x && s.y === y);
        if (conflict) continue;
        conflict = currentFoods.some(f => Math.abs(f.pos.x - x) < 4 && Math.abs(f.pos.y - y) < 4);
        if (conflict) continue;
        return { x, y };
      }
    }

    // Create or update food HTML elements (using KaTeX)
    function updateFoodElements() {
      foodElements.forEach(el => el.remove());
      foodElements = [];
      for (let food of foods) {
        let div = document.createElement("div");
        div.className = "food";
        div.style.left = (food.pos.x * CELL_SIZE) + "px";
        div.style.top = ((food.pos.y * CELL_SIZE) + 80) + "px"; // offset for question area
        katex.render(food.value, div, { throwOnError: false, displayMode: false });
        gameContainer.appendChild(div);
        foodElements.push(div);
      }
    }

    // Update question display using KaTeX
    function updateQuestion() {
      katex.render(currentQuestion.questionLatex, questionDiv, { throwOnError: false, displayMode: true });
    }

    // Update lives display (using hearts)
    function updateLives() {
      livesDiv.innerHTML = "â™¥".repeat(lives);
    }

    // Draw the game board and snake on the canvas (without grid lines)
    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Draw snake
      ctx.fillStyle = "green";
      for (let cell of snake) {
        ctx.fillRect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
      }
    }

    // Game update: move snake, check collisions, update state.
    function updateGame() {
      let newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
      if (newHead.x < 0 || newHead.x >= GRID_WIDTH || newHead.y < 0 || newHead.y >= GRID_HEIGHT) {
        endGame();
        return;
      }
      if (snake.some(cell => cell.x === newHead.x && cell.y === newHead.y)) {
        endGame();
        return;
      }
      snake.unshift(newHead);
      // Collision: if snake head is within 1 cell in both directions of a food cell.
      let hitFoodIndex = foods.findIndex(f => Math.abs(newHead.x - f.pos.x) <= 1 && Math.abs(newHead.y - f.pos.y) <= 1);
      if (hitFoodIndex !== -1) {
        let food = foods[hitFoodIndex];
        if (food.value === correctAnswer) {
          score++;
          currentQuestion = generateQuestion();
          correctAnswer = currentQuestion.answerLatex;
          foods = generateFoods(currentQuestion.func, correctAnswer, snake);
          updateFoodElements();
          updateQuestion();
        } else {
          lives--;
          foods.splice(hitFoodIndex, 1);
          let fe = foodElements.splice(hitFoodIndex, 1)[0];
          fe.remove();
          snake.pop(); // Do not grow.
          updateLives();
          if (lives <= 0) {
            endGame();
            return;
          }
        }
      } else {
        snake.pop();
      }
      drawGame();
    }

    function endGame() {
      clearInterval(gameInterval);
      alert("Game Over! Score: " + score);
      showMenu();
    }

    // Handle keyboard input for direction changes
    document.addEventListener("keydown", function(e) {
      if (gameState !== "playing") return;
      if (e.key === "ArrowUp" && direction.y !== 1) {
        direction = { x: 0, y: -1 };
      } else if (e.key === "ArrowDown" && direction.y !== -1) {
        direction = { x: 0, y: 1 };
      } else if (e.key === "ArrowLeft" && direction.x !== 1) {
        direction = { x: -1, y: 0 };
      } else if (e.key === "ArrowRight" && direction.x !== -1) {
        direction = { x: 1, y: 0 };
      }
    });

    // Menu and settings handling
    document.getElementById("playButton").addEventListener("click", function() {
      showGame();
    });
    document.getElementById("settingsButton").addEventListener("click", function() {
      showSettings();
    });
    document.getElementById("backButton").addEventListener("click", function() {
      settings.functions.sin = document.getElementById("sinCheckbox").checked;
      settings.functions.cos = document.getElementById("cosCheckbox").checked;
      settings.functions.tan = document.getElementById("tanCheckbox").checked;
      settings.quadrants[1] = document.getElementById("quad1").checked;
      settings.quadrants[2] = document.getElementById("quad2").checked;
      settings.quadrants[3] = document.getElementById("quad3").checked;
      settings.quadrants[4] = document.getElementById("quad4").checked;
      showMenu();
    });

    function showMenu() {
      gameState = "menu";
      menuDiv.style.display = "flex";
      settingsDiv.style.display = "none";
      gameContainer.style.display = "none";
    }
    function showSettings() {
      gameState = "settings";
      menuDiv.style.display = "none";
      settingsDiv.style.display = "flex";
      gameContainer.style.display = "none";
    }
    function showGame() {
      gameState = "playing";
      menuDiv.style.display = "none";
      settingsDiv.style.display = "none";
      gameContainer.style.display = "block";
      initGame();
      gameInterval = setInterval(updateGame, 1000 / 10);
    }

    // Start at the main menu.
    showMenu();
  </script>
</body>
</html>
